""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plug
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

call plug#begin('$VIM/vimfiles/my_plugin')

"状态栏
Plug 'itchyny/lightline.vim'

" color
Plug 'arcticicestudio/nord-vim'
Plug 'dracula/vim', { 'as': 'dracula' }

"匹配跳转
Plug 'vim-scripts/matchit.zip'

"文件树
"we can use the `:Explore` to use a more flexible explore.
"Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }

"Highlights trailing whitespace
Plug 'bronson/vim-trailing-whitespace'

"括号补全
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-surround'

"注释
Plug 'scrooloose/nerdcommenter'

"快速打开文件
Plug 'ctrlpvim/ctrlp.vim'

"快速移动
Plug 'easymotion/vim-easymotion'
Plug 'ludovicchabant/vim-gutentags'

"Coding
Plug 'machakann/vim-highlightedyank'
Plug 'godlygeek/tabular'
Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
Plug 'davidhalter/jedi-vim', { 'for': 'python' }

call plug#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" common setting
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""
"General
""""""""""""""""""""""""""""""""""""""""""""
set nocompatible
set nobackup
set noswapfile
set history=1024

"自动设置当前目录为正在编辑的目录
if exists('+autochdir')
  set autochdir
else
  autocmd BufEnter * silent! lcd %:p:h:gs/ /\\ /
endif

set viminfo='100,n$VIM/.vim/files/info/viminfo
set whichwrap=b,s,<,>,[,]
set nobomb
set backspace=indent,eol,start whichwrap+=<,>,[,]
" Vim 的默认寄存器和系统剪贴板共享
set clipboard=unnamed
" 设置 alt 键不映射到菜单栏
set winaltkeys=no

"关闭提示音
set noeb
set vb t_vb=

"https://xbeta.info/vim73b.htm
" conceallevel(简称cole)选项值: 具备conceal属性的字符串，并不一定是隐藏的。其具体表现取决于conceallevel的值。
" 0：默认值，显示。 因此，只设定conceal，并没有任何隐藏效果。
" 1：短线高亮。 匹配的字符串缩略显示为一个“-”符号（取决于listchars设定），并采用conceal组的高亮方案。
" 2：不显示，除非定义了cchar变量。举个例子就明白了，如下语句 `:syntax match Entity “&amp;”?conceal cchar=&` 可以把实体字符显示为原字符，更易于阅读。
" 3：完全不显示。
"更多参见：:h cole
set conceallevel=2

""""""""""""""""""""""""""""""""""""""""""""
"Encoding
""""""""""""""""""""""""""""""""""""""""""""
set tenc=utf-8
set encoding=utf-8
set fileencodings=utf-8,chinese,latin-1
"解决consle输出乱码
language messages zh_CN.utf-8
set guifont=等距更纱黑体_T_SC:h13

""""""""""""""""""""""""""""""""""""""""""""
"GUI
""""""""""""""""""""""""""""""""""""""""""""
" 设定命令行的行数为 2
set cmdheight=1
set noshowmode
" 状态栏显示目前所执行的指令
"if has("gui_running")
    "set lines=35 columns=100
"endif

" 设置 laststatus = 0 ，不显式状态行
" 设置 laststatus = 1 ，仅当窗口多于一个时，显示状态行
" 设置 laststatus = 2 ，总是显式状态行
set laststatus=2

" 使用指令变大变小
command! FontBigger :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)+1', '')
command! FontSmaller :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)-1', '')

set cursorline
"set cursorcolumn

if has("gui_running")
    " Switch on highlighting the last used search pattern.
    set hlsearch
else
    set t_Co=256
endif

" 开启实时搜索功能
set incsearch
" 搜索时大小写不敏感
set ignorecase
set smartcase

set number

" 分割出来的窗口位于当前窗口下边/右边
set splitbelow
set splitright

"不显示工具/菜单栏
set guioptions-=T
set guioptions-=m
set guioptions-=L
set guioptions-=r
set guioptions-=b

" 出现问题时恢复文件
"交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp
set directory=$VIM/vimfiles/swp//
set undodir=$VIM/vimfiles/undodir//
set undofile

" 监视文件改动
set autoread

" 命令模式下，底部操作指令按下 Tab 键自动补全。
" 第一次按下 Tab，会显示所有匹配的操作指令的清单；
" 第二次按下 Tab，会依次选择各个指令
set wildmenu
set wildmode=longest:list,full

""""""""""""""""""""""""""""""""""""""""""""
"Format
""""""""""""""""""""""""""""""""""""""""""""
set autoindent
set smartindent
set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab

filetype indent plugin on

" zc     折叠
" zC     对所在范围内所有嵌套的折叠点进行折叠
" zo     展开折叠
" zO     对所在范围内所有嵌套的折叠点展开
" [z     到当前打开的折叠的开始处。
" ]z     到当前打开的折叠的末尾处。
" zj     向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
" zk     向上移动到前一折叠的结束处。关闭的折叠也被计入。
" manual          手工定义折叠
" indent          更多的缩进表示更高级别的折叠
" expr            用表达式来定义折叠
" syntax          用语法高亮来定义折叠
" diff            对没有更改的文本进行折叠
" marker          对文中的标志折叠
" set foldmethod=marker
"关闭自动折叠
set nofoldenable


""""""""""""""""""""""""""""""""""""""""""""
"Key
""""""""""""""""""""""""""""""""""""""""""""
"set my leader
let mapleader=' '

" 定义快捷键关闭当前分割窗口
nmap <Leader>q :q<CR>
" 定义快捷键保存当前窗口内容
nmap <Leader>w :w<CR>

" 定义退出模式快捷键
inoremap kj <ESC>

" 定义vim设置文件内容相关
nnoremap <leader>ev :edit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

" 打开当前目录 explorer/cmd
nmap <silent> <leader>exp :!start explorer %:p:h<CR>
nmap <silent> <leader>cmd :!start cmd /k cd %:p:h<cr>

" 复制当前文件/路径到剪贴板
nmap <leader>cf :let @+=expand("%")<CR>
nmap <leader>cp :let @+=expand("%:p")<CR>

" 快速交换当前行位置
" 实际上交换本行和下面的行最简单可以使用 ddp
" 删除本行,下行补上,粘贴后贴到了下行
" nnoremap [l :<c-u>execute 'move -1-'. v:count1<cr>
" nnoremap ]l :<c-u>execute 'move +'. v:count1<cr>

" 快速添加空行
nnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>

" 设定n始终为向后，N始终为向前
nnoremap <expr> n  'Nn'[v:searchforward]
nnoremap <expr> N  'nN'[v:searchforward]

" 如果你选中了一行或多行，那么你可以用 < 或 > 来调整他们的缩进。但在调整之后就不会保持选中状态了。
" 你可以连续按下 g v 来重新选中他们，请参考 :h gv。因此，你可以这样来配置映射：
xnoremap < <gv
xnoremap > >gv

" 高级版本的重新绘制屏幕
" 这个映射就是执行重新绘制，并且取消通过 / 和 ? 匹配字符的高亮，而且还可以修复代码高亮问题
"（有时候，由于多个代码高亮的脚本重叠，或者规则过于复杂，Vim 的代码高亮显示会出现问题）。
" 不仅如此，还可以刷新「比较模式」
nnoremap <leader>rd :nohlsearch<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>

" 一键运行
map <F5> :call CompileRunGcc()<CR>
func! CompileRunGcc()
    exec "w"
    if &filetype == 'c'
        exec "!g++ % -o %<"
        exec "! %<"
    elseif &filetype == 'cpp'
        exec "!g++ % -o %<"
        exec "! %<"
    elseif &filetype == 'python'
        exec "!python %"
    elseif &filetype == 'sh'
        :!%
    endif
endfunc


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Plug setting
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"美化
""""""""""""""""""""""""""""""""""""""""""""
syntax on
"colorscheme nord
colorscheme dracula

" lightline
""""""""""""""""""""""""""""""""""""""""""""
let g:lightline = {
      \ 'colorscheme': 'nord',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'readonly', 'filename', 'modified'] ],
      \   'right': [ [ 'lineinfo' ],
      \              [ 'percent' ],
      \              [ 'fileformat', 'fileencoding', 'filetype'] ]
      \ },
      \ 'component_function': {
      \   'fileformat': 'LightlineFileformat',
      \   'filetype': 'LightlineFiletype',
      \   'filename': 'LightlineFilename',
      \ },
      \ }

function! LightlineFilename()
  let filename = expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
  let modified = &modified ? ' +' : ''
  return filename . modified
endfunction
function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction
function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

"文件树
""""""""""""""""""""""""""""""""""""""""""""
"nnoremap <leader>nt :NERDTreeToggle<CR>
""设定 NERDTree 视窗大小
"let g:NERDTreeWinSize = 30
""不显示隐藏文件
"let g:NERDTreeHidden  = 0
""Making it prettier
"let NERDTreeMinimalUI = 1
"let NERDTreeDirArrows = 1
"""修改树的显示图标
"let g:NERDTreeDirArrowExpandable = '►'
"let g:NERDTreeDirArrowCollapsible = '▼'
"let NERDTreeAutoCenter=1
"" 在终端启动vim时，共享NERDTree
"let g:nerdtree_tabs_open_on_console_startup=1
"" 忽略一下文件的显示
"let NERDTreeIgnore=['\.pyc','\~$','\.swp']
"""当NERDTree为剩下的唯一窗口时自动关闭
"autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

"Highlights trailing whitespace
""""""""""""""""""""""""""""""""""""""""""""
nmap <leader>tw :FixWhitespace<cr>

"全局搜索
""""""""""""""""""""""""""""""""""""""""""""
" <leader>vv 可以在当前目录下全局搜索指针选择的单词
" 例如我们要全局搜索一段字符串str-star，可以在可视模式下通过光标移动选择该字符串，
" 之后按下快捷键 <leader>vv，即完成字符串的搜索，很方便
" 当然，我们也可以直接进行全局搜索，使用指令
" :Grep 搜索字符串
" 全局替换也可以
" :Replace [target] [replacement]

"快速打开文件
""""""""""""""""""""""""""""""""""""""""""""
let g:ctrlp_map = '<leader>p'
let g:ctrlp_cmd = 'CtrlP'
" 使用vim的忽略文件
set wildignore+=*\\node_modules\\*,*.git*,*.svn*,*.zip*,*.exe*,*.pyc*,*.bin*,*.7z*,*.rar*

"快速移动
""""""""""""""""""""""""""""""""""""""""""""
" <leader><leader>w                       从光标位置起，往前（往下）在单词之间移动光标
" <leader><leader>b                       从光标位置起，往后（往上）在单词之间移动光标
" <leader><leader>s                       从光标位置起，同时往前往后，在单词之间移动光标
" <leader><leader>f｛char｝               从光标位置起，往前（往下）在单个字符之间移动光标

"Tags
" gutentags搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归 "
let g:gutentags_project_root = ['.root', '.svn', '.git', '.project', 'output', '.idea', '.vscode']

" 所生成的数据文件的名称 "
let g:gutentags_ctags_tagfile = '.tags'

" 将自动生成的 tags 文件全部放入指定目录中，避免污染工程目录 "
let s:vim_tags = expand('D:/TEMP/TGAS')
let g:gutentags_cache_dir = s:vim_tags
" 检测 vim_tags 不存在就新建 "
if !isdirectory(s:vim_tags)
   silent! call mkdir(s:vim_tags, 'p')
endif

" 配置 ctags 的参数 "
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
let g:gutentags_ctags_extra_args += ['--python-kinds=+cfmvi']

"vim-surround
""""""""""""""""""""""""""""""""""""""""""""
" 光标在
" “Hello world!”
" 中时按下cs"'，则会替换双引号为单引号：
" ‘Hello world!’
" 继续按下cs'<q>，则会替换单引号为 “标签”
" 'Hello world!'
" 按下cst"，则回到初始的双引号：
" “Hello world!”
" 要删除符号，则按下ds"
" Hello world!
" 当光标在hello上时，按下ysiw]，则会变为
" [Hello] world!
" 添加包围符号的命令是ys(ys可以记为you surround)，命令后同样跟两个参数，第一
" 个是一个vim“动作”（motion）或者是一个文本对象,其中motion即vim动作，比如说w
" 向后一个单词。文本对象简单的来说主要是来通过一些分隔符来标识一段文本，比如
" iw就是一个文本对象，即光标下的单词。
" 另外： yss 命令可以用于整行操作，忽略中间的空格,
" yS 和 ySS 还能让包围内容单独一行并且加上缩进。
" 加包围符号还有个非常好用的方式：在可视模式v下，按下S后即可添加想要添加的包围符号了。
" 再说一个小技巧：在包围符号为括时，输入左括号 (或者{ ,则会留一个空格

"markdown
""""""""""""""""""""""""""""""""""""""""""""
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_folding_level = 6
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_math = 1
let g:vim_markdown_frontmatter = 1
let g:vim_markdown_strikethrough = 1
let g:vim_markdown_autowrite = 1
let g:vim_markdown_auto_insert_bullets = 0
let g:vim_markdown_edit_url_in = 'tab'  " tab, vsplit, hsplit, current

"python
""""""""""""""""""""""""""""""""""""""""""""
let g:jedi#goto_command = "<leader>gg"
let g:jedi#goto_assignments_command = "<leader>ga"
let g:jedi#goto_stubs_command = "<leader>gs"
let g:jedi#goto_definitions_command = "<leader>gd"
let g:jedi#documentation_command = "K"
let g:jedi#usages_command = "<leader>n"
let g:jedi#completions_command = "<C-N>"
let g:jedi#rename_command = "<leader>r"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           auto setting
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 针对python文件自动添加头部信息
func! SetTitle()
    call setline(1, "\# -*- coding=utf8 -*-")
    call setline(2, "\"\"\"")
    call setline(3, "\# @Author : lart")
    call setline(4, "\# @Created Time : ".strftime("%Y-%m-%d %H:%M:%S"))
    call setline(5, "\# @Description :")
    call setline(6, "\"\"\"")
    normal G
    normal o
    normal o
endfunc

" vim 文件折叠方式为 marker
augroup ft_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker

    autocmd bufnewfile *.py call SetTitle()

    " 打开文件总是定位到上次编辑的位置
    autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif
augroup END
